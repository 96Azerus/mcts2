<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>OFC Pineapple AI</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        /* Общие стили */
        :root {
            --card-width: 45px; --card-height: 65px; --card-font-size: 14px;
            --card-rank-font-size: 1.2em; --card-suit-font-size: 0.9em;
            --row-gap: 8px; --row-min-height: 75px; --table-padding: 10px;
            --hand-area-padding: 10px; --hand-gap: 8px;
        }
        html { box-sizing: border-box; }
        *, *:before, *:after { box-sizing: inherit; }
        body { margin: 0; padding: 10px; font-family: Arial, sans-serif; background-color: #f0f0f0; overflow-x: hidden; min-height: 100vh; padding-bottom: 150px; display: flex; flex-direction: column; }
        button { padding: 10px 20px; font-size: 15px; border: none; border-radius: 5px; cursor: pointer; background-color: #4CAF50; color: white; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        button:hover:not(:disabled) { background-color: #45a049; transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        button:active:not(:disabled) { transform: translateY(1px); box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        button:disabled { background-color: #cccccc; cursor: not-allowed; opacity: 0.7; }

        /* Управление */
        .controls { display: flex; justify-content: center; flex-wrap: wrap; gap: 10px; margin-bottom: 15px; position: sticky; top: 0; z-index: 1001; background: #f0f0f0; padding: 10px; border-bottom: 1px solid #ccc; }
        .fullscreen-btn { position: fixed; top: 5px; right: 5px; background: none; border: none; color: #333; cursor: pointer; z-index: 1002; padding: 5px; box-shadow: none; }
        .fullscreen-btn .material-icons { font-size: 28px; }

        /* Игровой стол */
        .game-area { display: flex; flex-direction: column; align-items: center; width: 100%; }
        .table { display: grid; grid-template-rows: auto auto auto; gap: var(--row-gap); margin: 10px auto; width: 98%; max-width: 600px; background-color: #1a472a; padding: var(--table-padding); border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .row { display: flex; justify-content: center; gap: 1.5%; min-height: var(--row-min-height); padding: 5px; border-radius: 5px; background-color: rgba(255,255,255,0.1); flex-wrap: nowrap; align-items: center; }
        .player-label { text-align: center; color: white; font-weight: bold; margin-bottom: 3px; font-size: 14px; }

        /* Карты и слоты */
        .card { width: var(--card-width); height: var(--card-height); border-radius: 4px; background-color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: var(--card-font-size); font-weight: bold; box-shadow: 0 1px 3px rgba(0,0,0,0.2); position: relative; flex-shrink: 0; transition: transform 0.2s, box-shadow 0.2s, border 0.2s; user-select: none; -webkit-user-select: none; touch-action: none; border: 2px solid transparent; padding: 2px; cursor: grab; }
        .card span:first-child { font-size: var(--card-rank-font-size); }
        .card span:last-child { font-size: var(--card-suit-font-size); margin-top: 2px; }
        .card[data-suit="♥"], .card[data-suit="♦"] { color: #e44145; }
        .card[data-suit="♣"], .card[data-suit="♠"] { color: #2d2d2d; }
        .card.dragging { opacity: 0.4; cursor: grabbing; transform: scale(1.05); box-shadow: 0 4px 8px rgba(0,0,0,0.3); z-index: 1100; }
        .card.selected { border: 2px solid #dc3545 !important; background-color: rgba(220, 53, 69, 0.1); }
        .card-slot { width: var(--card-width); height: var(--card-height); border: 1px dashed rgba(255,255,255,0.3); border-radius: 4px; flex-shrink: 0; transition: all 0.3s ease; display: flex; justify-content: center; align-items: center; }
        .card-slot.available { border: 2px dashed #aaffaa; cursor: pointer; }
        .card-slot.available:hover { background-color: rgba(170, 255, 170, 0.2); }
        .card-slot.drag-over { background-color: rgba(170, 255, 170, 0.4); border-style: solid; transform: scale(1.05); }
        .card-slot .card { cursor: default; }
        .card-slot .card.placed-this-turn { cursor: grab; }

        /* Область руки и сброса */
        #hand-area { position: fixed; bottom: 0; left: 0; right: 0; background: #e0e0e0; padding: var(--hand-area-padding); display: flex; flex-direction: column; justify-content: center; gap: 8px; z-index: 1000; box-shadow: 0 -2px 10px rgba(0,0,0,0.1); min-height: 90px; align-items: center;}
        #hand { display: flex; justify-content: center; gap: var(--hand-gap); flex-wrap: wrap; min-height: 70px; width: 100%; }
        #hand .card.placed { display: none; }
        #fl-discard-area { margin-top: 5px; text-align: center; width: 100%; }
        #fl-discard-area span { font-size: 12px; color: #555; display: block; margin-bottom: 5px; }
        #fl-discard-options { display: flex; justify-content: center; gap: 5px; flex-wrap: wrap; }
        #fl-discard-options .card { border: 1px solid #ccc; cursor: pointer; }
        #fl-discard-options .card.discard-selected { border: 2px solid #dc3545 !important; background-color: rgba(220, 53, 69, 0.1); }
        .player-discard-info { margin-top: 5px; text-align: center; color: #555; font-size: 12px; padding: 0 10px; width: 100%; }

        /* Сообщения и оверлей */
        .message-area { text-align: center; margin-bottom: 10px; font-weight: bold; color: #333; min-height: 20px; font-size: 14px;}
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 1005; display: flex; justify-content: center; align-items: center; color: white; font-size: 1.5em; display: none; /* СКРЫТ ПО УМОЛЧАНИЮ */ }

        /* --- Мобильная адаптация --- */
        @media (max-width: 640px) {
            :root { --card-width: 38px; --card-height: 55px; --card-font-size: 11px; --card-rank-font-size: 1.1em; --card-suit-font-size: 0.8em; --row-gap: 5px; --row-min-height: 65px; --table-padding: 5px; --hand-area-padding: 5px; --hand-gap: 4px; }
            body { padding-bottom: 120px; padding-left: 5px; padding-right: 5px; }
            .controls button { padding: 8px 12px; font-size: 14px; }
            .player-label { font-size: 12px; }
            .message-area { font-size: 13px; }
            #hand-area { min-height: 75px; }
            #hand { min-height: 60px; }
            .player-discard-info { font-size: 11px; }
            #fl-discard-area span { font-size: 11px; }
        }
         @media (max-width: 380px) {
             :root { --card-width: 32px; --card-height: 48px; --card-font-size: 9px; --row-min-height: 58px; }
             .controls { gap: 5px; }
             .controls button { padding: 6px 10px; font-size: 12px; }
             .player-label { font-size: 11px; }
             .message-area { font-size: 12px; }
         }
    </style>
</head>
<body>
    <button class="fullscreen-btn" onclick="toggleFullScreen()" title="Полный экран">
        <span class="material-icons">fullscreen</span>
    </button>

    <div class="controls">
        <button id="start-button" onclick="startGame()">Начать Раунд</button>
        <button id="ready-button" onclick="confirmTurn()" disabled>Готов</button>
    </div>

    <div class="message-area" id="message-area">Загрузка...</div>

    <div class="game-area">
         <div class="player-label">AI Player</div>
        <div class="table" id="ai-table">
            <div class="row top" id="ai-top-row"></div>
            <div class="row middle" id="ai-middle-row"></div>
            <div class="row bottom" id="ai-bottom-row"></div>
        </div>

        <div class="player-label">Human Player (Вы)</div>
        <div class="table" id="player-table">
            <div class="row top" id="player-top-row"></div>
            <div class="row middle" id="player-middle-row"></div>
            <div class="row bottom" id="player-bottom-row"></div>
        </div>
    </div>

    <div id="hand-area">
        <div id="hand"></div>
        <div id="fl-discard-area" style="display: none;">
             <span>Выберите карту(ы) для сброса:</span>
             <div id="fl-discard-options"></div>
        </div>
        <div class="player-discard-info" id="player-discard-info">Ваш сброс: 0 карт</div>
    </div>

    <div class="overlay" id="waiting-overlay">Ожидание...</div>

<script>
    // --- Глобальные переменные ---
    let currentGameState = null;
    let humanPlayerIndex = 0;
    let draggedCardElement = null;
    let placedCardsMap = new Map(); // cardStr -> { element, row, index, isFinal }
    let selectedCardToDiscardElement = null; // Для улиц 2-5
    let flDiscardSelection = new Set(); // cardStr - для ФЛ

    // --- Ссылки на DOM элементы ---
    const readyButton = document.getElementById('ready-button');
    const messageArea = document.getElementById('message-area');
    const handElement = document.getElementById('hand');
    const playerDiscardInfo = document.getElementById('player-discard-info');
    const waitingOverlay = document.getElementById('waiting-overlay');
    const flDiscardArea = document.getElementById('fl-discard-area');
    const flDiscardOptions = document.getElementById('fl-discard-options');
    const startButton = document.getElementById('start-button');

    // --- Функции DnD (без изменений) ---
    function handleDragStart(event) {
        // console.log("JS: handleDragStart");
        const target = event.target;
        // Разрешаем перетаскивать только карты из руки или те, что были размещены в этом ходу
        if (target.classList.contains('card') && (target.parentElement?.id === 'hand' || target.classList.contains('placed-this-turn'))) {
            // Нельзя перетаскивать карту, выбранную для сброса
            if (target.classList.contains('selected')) {
                event.preventDefault();
                return;
            }
            draggedCardElement = target;
            try {
                 event.dataTransfer.setData('text/plain', target.dataset.card);
                 event.dataTransfer.effectAllowed = 'move';
            } catch (e) { console.error("JS Error setting drag data:", e); event.preventDefault(); return; }
            // Добавляем класс с небольшой задержкой для лучшего визуального эффекта
            requestAnimationFrame(() => { if(draggedCardElement) draggedCardElement.classList.add('dragging'); });
        } else {
            // Запрещаем перетаскивание других элементов
            event.preventDefault();
        }
    }
    function handleDragOver(event) {
        // console.log("JS: handleDragOver");
        event.preventDefault(); // Необходимо для срабатывания drop
        const dropZone = event.target.closest('.card-slot');
        const handZone = event.target.closest('#hand');

        // Подсветка доступного слота
        if (dropZone && dropZone.classList.contains('available')) {
            event.dataTransfer.dropEffect = 'move';
            // Добавляем класс подсветки, если его еще нет
            if (!dropZone.classList.contains('drag-over')) {
                // Убираем подсветку с других слотов
                document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                dropZone.classList.add('drag-over');
            }
        }
        // Разрешаем возврат карты в руку, если она была размещена в этом ходу
        else if (handZone && draggedCardElement && draggedCardElement.classList.contains('placed-this-turn')) {
             event.dataTransfer.dropEffect = 'move';
             // Убираем подсветку со слотов при наведении на руку
             document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        }
        // Запрещаем бросать в другие места
        else {
             document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
             event.dataTransfer.dropEffect = 'none';
        }
    }
    function handleDragLeave(event) {
        // console.log("JS: handleDragLeave");
        const dropZone = event.target.closest('.card-slot');
        // Убираем подсветку, если покинули слот и не вошли в дочерний элемент
        if (dropZone && event.relatedTarget && !dropZone.contains(event.relatedTarget)) {
            dropZone.classList.remove('drag-over');
        }
        // Убираем подсветку, если вышли за пределы стола или руки
        if (!event.relatedTarget || (!event.relatedTarget.closest('.table') && !event.relatedTarget.closest('#hand'))) {
             document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        }
    }
    function handleDrop(event) {
        // console.log("JS: handleDrop");
        event.preventDefault();
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        if (!draggedCardElement) return;

        const cardStr = draggedCardElement.dataset.card;
        const targetSlot = event.target.closest('.card-slot.available');
        const targetHand = event.target.closest('#hand');

        // --- Случай 1: Карта брошена в доступный слот ---
        if (targetSlot) {
            const row = targetSlot.dataset.row;
            const index = parseInt(targetSlot.dataset.index);

            // Если карта уже была размещена где-то в этом ходу, очищаем старый слот
            if (placedCardsMap.has(cardStr)) {
                const oldPlacement = placedCardsMap.get(cardStr);
                const oldSlot = document.querySelector(`#player-table .card-slot[data-row='${oldPlacement.row}'][data-index='${oldPlacement.index}']`);
                if (oldSlot && oldSlot.firstChild === draggedCardElement) {
                    oldSlot.innerHTML = ''; // Очищаем старый слот
                    oldSlot.classList.add('available'); // Делаем старый слот доступным
                }
            } else {
                // Если карта была в руке, помечаем ее как размещенную (скрываем в руке)
                draggedCardElement.classList.add('placed');
            }

            // Перемещаем карту в новый слот
            targetSlot.appendChild(draggedCardElement);
            targetSlot.classList.remove('available'); // Слот больше не доступен
            draggedCardElement.classList.add('placed-this-turn'); // Помечаем как размещенную в этом ходу
            draggedCardElement.classList.remove('dragging'); // Убираем стиль перетаскивания

            // Обновляем карту размещений
            placedCardsMap.set(cardStr, { element: draggedCardElement, row: row, index: index, isFinal: false });
            draggedCardElement = null; // Сбрасываем перетаскиваемый элемент
            updateUIState(); // Обновляем состояние UI (кнопки, доступность слотов и т.д.)
            // console.log(`JS: Card ${cardStr} dropped in slot ${row}[${index}]`);
        }
        // --- Случай 2: Карта возвращена в руку ---
        else if (targetHand && draggedCardElement.classList.contains('placed-this-turn')) {
             // Если карта была размещена в этом ходу, возвращаем ее в руку
             if (placedCardsMap.has(cardStr)) {
                 const oldPlacement = placedCardsMap.get(cardStr);
                 const oldSlot = document.querySelector(`#player-table .card-slot[data-row='${oldPlacement.row}'][data-index='${oldPlacement.index}']`);
                 // Очищаем старый слот
                 if (oldSlot && oldSlot.firstChild === draggedCardElement) {
                     oldSlot.innerHTML = '';
                     oldSlot.classList.add('available');
                 }
                 // Удаляем из карты размещений
                 placedCardsMap.delete(cardStr);
                 // Возвращаем карту в исходное состояние
                 draggedCardElement.classList.remove('placed-this-turn');
                 draggedCardElement.classList.remove('placed'); // Показываем в руке
                 draggedCardElement.classList.remove('dragging');
                 // Возвращаем карту в контейнер руки (DOM) - не обязательно, т.к. она там и осталась, просто скрыта
                 // handElement.appendChild(draggedCardElement); // Можно раскомментировать для надежности
                 draggedCardElement = null;
                 updateUIState();
                 // console.log(`JS: Card ${cardStr} returned to hand`);
             }
        }
        // --- Случай 3: Неудачный дроп ---
        else {
            handleDragEnd(); // Просто убираем стиль перетаскивания
        }
    }
    function handleDragEnd(event) {
        // console.log("JS: handleDragEnd");
        // Убираем стиль перетаскивания, если элемент еще существует
        if (draggedCardElement) {
            draggedCardElement.classList.remove('dragging');
        }
        // Убираем подсветку со всех слотов
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        // Сбрасываем перетаскиваемый элемент
        draggedCardElement = null;
    }

    // --- Вспомогательные функции ---
    function getCardSuitSymbol(suitChar) { const map = {'c': '♣', 'd': '♦', 'h': '♥', 's': '♠'}; return map[suitChar.toLowerCase()] || suitChar; }
    function createCardElement(cardStr, isDraggable = false) {
        // console.log(`JS: createCardElement for ${cardStr}`);
        if (!cardStr || cardStr === "__" || cardStr === "InvalidCard") {
             // console.log(`JS: Skipping creation for invalid card string: ${cardStr}`);
             return null;
        }
        try {
            const cardElement = document.createElement('div');
            cardElement.className = 'card';
            // Исправляем извлечение ранга для '10'
            const rank = cardStr.length > 2 && cardStr.startsWith('T') ? 'T' : cardStr.substring(0, 1); // Используем T для десятки
            const suitChar = cardStr.substring(cardStr.length - 1);
            const suitSymbol = getCardSuitSymbol(suitChar);

            if (!rank || !suitSymbol || !CardHelper.isValidRank(rank) || !CardHelper.isValidSuit(suitChar)) {
                 console.error(`JS Error: Could not parse rank/suit from ${cardStr}`);
                 return null;
            }

            cardElement.dataset.card = cardStr;
            cardElement.dataset.rank = rank;
            cardElement.dataset.suit = suitSymbol;
            cardElement.innerHTML = `<span>${rank.toUpperCase()}</span><span>${suitSymbol}</span>`;

            if (suitSymbol === '♥' || suitSymbol === '♦') { cardElement.style.color = '#e44145'; }
            else { cardElement.style.color = '#2d2d2d'; }

            if (isDraggable) {
                cardElement.draggable = true;
                // Обработчик клика добавляется в updateUIState в зависимости от контекста
            } else {
                cardElement.draggable = false;
                cardElement.style.cursor = 'default';
            }
            return cardElement;
        } catch (error) {
             console.error(`JS Error in createCardElement for ${cardStr}:`, error);
             return null; // Возвращаем null при ошибке
        }
    }
    function createCardSlotElement(row, index, isPlayerBoard = false) { const slot = document.createElement('div'); slot.className = 'card-slot'; slot.dataset.row = row; slot.dataset.index = index; if (isPlayerBoard) { slot.classList.add('available'); } return slot; }

    // --- Функции обновления UI ---
    function renderBoard(playerPrefix, boardData, isPlayerBoard = false) {
        // console.log(`JS: renderBoard START for ${playerPrefix}`);
        try {
            const rows = { 'top': document.getElementById(`${playerPrefix}-top-row`), 'middle': document.getElementById(`${playerPrefix}-middle-row`), 'bottom': document.getElementById(`${playerPrefix}-bottom-row`) };
            if (!rows.top || !rows.middle || !rows.bottom) { console.error("JS Error: Board row elements not found for prefix:", playerPrefix); return; }
            Object.values(rows).forEach(row => { if(row) row.innerHTML = ''; }); // Очищаем ряды

            ['top', 'middle', 'bottom'].forEach(rowName => {
                const rowElement = rows[rowName];
                if (!rowElement) return;
                const rowCards = boardData[rowName] || [];
                const capacity = rowName === 'top' ? 3 : 5;
                for (let i = 0; i < capacity; i++) {
                    const cardStr = rowCards[i] || "__";
                    const slot = createCardSlotElement(rowName, i, isPlayerBoard); // Создаем слот
                    const cardEl = createCardElement(cardStr, false); // Создаем карту (неперетаскиваемую)
                    if (cardEl) { // Если карта валидна
                        slot.appendChild(cardEl); // Добавляем карту в слот
                        if(isPlayerBoard) slot.classList.remove('available'); // Занятый слот не доступен
                    } else if (isPlayerBoard) { // Если карта невалидна (или "__"), но это доска игрока
                         slot.classList.add('available'); // Пустой слот доступен
                    }
                    rowElement.appendChild(slot); // Добавляем слот в ряд
                }
            });
            // console.log(`JS: renderBoard for ${playerPrefix} FINISHED`);
        } catch (error) { console.error(`JS Error in renderBoard for ${playerPrefix}:`, error); }
    }

    function renderHand(handCards) {
        // console.log("JS: renderHand START with cards:", handCards);
        try {
            handElement.innerHTML = ''; // Очищаем руку
            // Сортируем карты для консистентности отображения
            const sortedHand = Array.isArray(handCards) ? [...handCards].sort(CardHelper.compareCards) : [];
            // Сохраняем текущее состояние руки для сравнения в updateUI
            handElement.dataset.currentHand = JSON.stringify(sortedHand);

            if (sortedHand.length > 0) {
                sortedHand.forEach(cardStr => {
                    // Создаем перетаскиваемые карты
                    const cardEl = createCardElement(cardStr, true);
                    if (cardEl) handElement.appendChild(cardEl); // Добавляем только валидные карты
                });
            }
            // Сбрасываем состояние перетаскивания и выбора
            clearUIState();
            // console.log("JS: renderHand FINISHED");
        } catch (error) { console.error("JS Error in renderHand:", error); }
    }

    function clearUIState() {
         // console.log("JS: clearUIState START");
         draggedCardElement = null;
         placedCardsMap.clear();
         if(selectedCardToDiscardElement) {
             selectedCardToDiscardElement.classList.remove('selected');
             selectedCardToDiscardElement = null;
         }
         flDiscardSelection.clear();
         flDiscardArea.style.display = 'none';
         flDiscardOptions.innerHTML = '';
         // Убираем классы с карт и слотов
         document.querySelectorAll('.card.placed-this-turn').forEach(c => c.classList.remove('placed-this-turn'));
         document.querySelectorAll('.card.placed').forEach(c => c.classList.remove('placed'));
         document.querySelectorAll('.card.selected').forEach(c => c.classList.remove('selected'));
         document.querySelectorAll('.card-slot.drag-over').forEach(s => s.classList.remove('drag-over'));
         // Показываем все карты в руке
         Array.from(handElement.children).forEach(c => c.style.display = 'flex');
         // Обновляем состояние кнопок и доступности слотов
         updateUIState();
         // console.log("JS: clearUIState FINISHED");
    }

    function updateUI(stateData) {
        // console.log("JS: updateUI START with state:", JSON.stringify(stateData));
        if (!stateData || typeof stateData !== 'object') { console.error("JS Error: Invalid stateData received in updateUI", stateData); messageArea.textContent = "Ошибка: Некорректные данные от сервера."; return; }
        try {
            const wasGameOver = currentGameState?.isGameOver ?? true;
            const previousStreet = currentGameState?.street ?? 0;
            const previousHandStr = handElement.dataset.currentHand || '[]';

            currentGameState = stateData;
            humanPlayerIndex = stateData.humanPlayerIndex;

            // console.log(`JS updateUI: Setting overlay display based on isWaiting=${stateData.isWaiting}`);
            waitingOverlay.style.display = stateData.isWaiting ? 'flex' : 'none';

            // Рендерим доски
            renderBoard('player', stateData.playerBoard, true);
            renderBoard('ai', stateData.opponentBoard, false);

            // Определяем, может ли игрок ходить
            const canPlayerAct = !stateData.isGameOver && !stateData.playerFinishedRound && !stateData.isWaiting;
            const isFLTurn = canPlayerAct && stateData.isFantasylandRound && stateData.playerFantasylandStatus;
            const handToRender = isFLTurn ? stateData.fantasylandHand : stateData.hand;
            const currentHandSorted = Array.isArray(handToRender) ? [...handToRender].sort(CardHelper.compareCards) : [];
            const currentHandStr = JSON.stringify(currentHandSorted);

            // console.log(`JS updateUI: canPlayerAct=${canPlayerAct}, isFLTurn=${isFLTurn}`);
            // console.log(`JS updateUI: Prev Hand: ${previousHandStr}, Curr Hand: ${currentHandStr}`);

            // Перерисовываем руку только если:
            // 1. Ход игрока И (рука изменилась ИЛИ началась новая игра/раунд ИЛИ сменилась улица)
            // 2. Не ход игрока, но рука была отображена (нужно очистить)
            if (canPlayerAct && (currentHandStr !== previousHandStr || (wasGameOver && !stateData.isGameOver) || stateData.street !== previousStreet)) {
                 // console.log("JS updateUI: Rendering hand");
                 renderHand(handToRender || []); // Передаем пустой массив, если null
            } else if (!canPlayerAct && handElement.children.length > 0) {
                 // console.log("JS updateUI: Clearing hand (not player turn)");
                 renderHand([]); // Очищаем руку, если не ход игрока
            } else {
                 // console.log("JS updateUI: Hand not changed, calling updateUIState directly");
                 // Если рука не менялась, просто обновляем состояние кнопок/слотов
                 updateUIState();
            }

            // Обновляем информацию
            playerDiscardInfo.textContent = `Ваш сброс: ${stateData.playerDiscardCount || 0} карт`;
            messageArea.textContent = stateData.message || "Загрузка...";
            if (stateData.error_message) {
                messageArea.textContent += ` | Ошибка: ${stateData.error_message}`;
                messageArea.style.color = 'red'; // Выделяем ошибку
            } else {
                 messageArea.style.color = '#333'; // Возвращаем стандартный цвет
            }

            // Обновляем кнопку Start
            startButton.disabled = !stateData.isGameOver;
            // console.log(`JS updateUI: Start button disabled = ${!stateData.isGameOver}`);

            // console.log("JS: updateUI FINISHED");
        } catch (error) { console.error("JS Error in updateUI:", error); messageArea.textContent = "Ошибка отображения интерфейса."; }
    }

    function updateUIState() {
        // console.log("JS: updateUIState START");
        if (!currentGameState) { /* console.log("JS updateUIState: No currentGameState"); */ return; }
        try {
            const canPlayerAct = !currentGameState.isGameOver && !currentGameState.playerFinishedRound && !currentGameState.isWaiting;
            const isFL = canPlayerAct && currentGameState.isFantasylandRound && currentGameState.playerFantasylandStatus;
            const placedCount = placedCardsMap.size;
            let requiredPlacement = 0;
            let requiredDiscard = 0;
            let isReady = false;
            flDiscardArea.style.display = 'none'; // Скрываем по умолчанию

            if (isFL) {
                // --- Логика для Фантазии ---
                requiredPlacement = 13;
                const originalHandSize = currentGameState.fantasylandHand?.length || 0;
                requiredDiscard = Math.max(0, originalHandSize - 13);
                isReady = placedCount === requiredPlacement && flDiscardSelection.size === requiredDiscard;
                readyButton.textContent = "Разместить Фантазию";

                // Показываем опции для сброса, если нужно
                if (canPlayerAct && requiredDiscard > 0) {
                     flDiscardArea.style.display = 'block';
                     flDiscardOptions.innerHTML = ''; // Очищаем предыдущие опции
                     const handCards = currentGameState.fantasylandHand || [];
                     handCards.forEach(cardStr => {
                         // Показываем только те карты, которые еще не размещены
                         if (!placedCardsMap.has(cardStr)) {
                             const cardEl = createCardElement(cardStr, false); // Карты для сброса не перетаскиваются
                             if (cardEl) {
                                 cardEl.style.cursor = 'pointer';
                                 cardEl.onclick = () => toggleFLDiscardSelection(cardEl);
                                 // Помечаем выбранные для сброса
                                 if (flDiscardSelection.has(cardStr)) {
                                     cardEl.classList.add('discard-selected');
                                 }
                                 flDiscardOptions.appendChild(cardEl);
                             }
                         }
                     });
                     // Скрываем область, если все карты размещены (нет опций для сброса)
                     if(flDiscardOptions.children.length === 0) {
                          flDiscardArea.style.display = 'none';
                     }
                }
            } else if (canPlayerAct) {
                // --- Логика для обычного хода ---
                if (currentGameState.street === 1) {
                    requiredPlacement = 5;
                    requiredDiscard = 0;
                    isReady = placedCount === requiredPlacement;
                } else if (currentGameState.street >= 2 && currentGameState.street <= 5) {
                    requiredPlacement = 2;
                    requiredDiscard = 1;
                    // Готов, если 2 карты размещены и 1 выбрана для сброса
                    isReady = placedCount === requiredPlacement && !!selectedCardToDiscardElement;
                }
                readyButton.textContent = "Готов";
            }

            // Обновляем состояние кнопки "Готов"
            readyButton.disabled = !isReady || !canPlayerAct;

            // Обновляем состояние слотов на доске игрока
            document.querySelectorAll('#player-table .card-slot').forEach(slot => {
                const isOccupied = !!slot.firstChild;
                const cardEl = slot.firstChild;
                const cardStr = isOccupied ? cardEl.dataset.card : null;
                // Можно бросить карту, если слот пуст, игрок может ходить и не все карты размещены
                const canDrop = !isOccupied && canPlayerAct && placedCount < requiredPlacement;
                // Можно перетащить карту из слота, если она была размещена в этом ходу
                const canDragFrom = isOccupied && placedCardsMap.has(cardStr) && !placedCardsMap.get(cardStr).isFinal && canPlayerAct;

                slot.classList.toggle('available', canDrop);
                if (cardEl) {
                    cardEl.draggable = canDragFrom;
                    cardEl.classList.toggle('placed-this-turn', canDragFrom);
                    cardEl.onclick = null; // Убираем клик со слотов
                    cardEl.style.cursor = canDragFrom ? 'grab' : 'default';
                }
            });

            // Обновляем состояние карт в руке
             Array.from(handElement.children).forEach(cardEl => {
                 const cardStr = cardEl.dataset.card;
                 const isPlaced = placedCardsMap.has(cardStr);
                 const isSelectedForDiscard = selectedCardToDiscardElement === cardEl;

                 // Карта перетаскиваема, если она не размещена, игрок ходит и она не выбрана для сброса
                 cardEl.draggable = !isPlaced && canPlayerAct && !isSelectedForDiscard;
                 // Скрываем карту в руке, если она размещена
                 cardEl.style.display = isPlaced ? 'none' : 'flex';
                 // Помечаем карту, выбранную для сброса
                 cardEl.classList.toggle('selected', isSelectedForDiscard);

                 // Добавляем обработчик клика для выбора сброса (только улицы 2-5 и если 2 карты уже размещены)
                 if (!isFL && currentGameState.street > 1 && canPlayerAct && !isPlaced && placedCount === 2) {
                     cardEl.onclick = () => handleCardClick(cardEl);
                     cardEl.style.cursor = 'pointer'; // Указываем, что можно кликнуть
                 } else {
                     cardEl.onclick = null; // Убираем обработчик клика в других случаях
                     cardEl.style.cursor = cardEl.draggable ? 'grab' : 'default';
                 }
             });
             // console.log("JS: updateUIState FINISHED");
        } catch(error) { console.error("JS Error in updateUIState:", error); }
    }

    // --- Обработчики действий пользователя ---
    function handleCardClick(cardElement) {
        // console.log("JS: handleCardClick for", cardElement.dataset.card);
        // Обработка клика для выбора карты для сброса (улицы 2-5)
        if (!currentGameState || currentGameState.isGameOver || currentGameState.playerFinishedRound || currentGameState.isWaiting) return;
        if (currentGameState.isFantasylandRound && currentGameState.playerFantasylandStatus) return; // Не для ФЛ
        if (currentGameState.street <= 1) return; // Только для улиц 2-5
        if (placedCardsMap.size !== 2) return; // Только если 2 карты уже размещены

        // Снимаем выделение с предыдущей карты
        if (selectedCardToDiscardElement && selectedCardToDiscardElement !== cardElement) {
            selectedCardToDiscardElement.classList.remove('selected');
        }

        // Выбираем или снимаем выбор с текущей карты
        if (selectedCardToDiscardElement === cardElement) {
            selectedCardToDiscardElement.classList.remove('selected');
            selectedCardToDiscardElement = null;
        } else {
            cardElement.classList.add('selected');
            selectedCardToDiscardElement = cardElement;
        }
        updateUIState(); // Обновляем состояние кнопки "Готов"
    }

    function toggleFLDiscardSelection(cardElement) {
        // console.log("JS: toggleFLDiscardSelection for", cardElement.dataset.card);
        if (!currentGameState || !currentGameState.isFantasylandRound || !currentGameState.playerFantasylandStatus) return;

        const cardStr = cardElement.dataset.card;
        const originalHandSize = currentGameState.fantasylandHand?.length || 0;
        const requiredDiscard = Math.max(0, originalHandSize - 13);

        if (flDiscardSelection.has(cardStr)) {
            flDiscardSelection.delete(cardStr);
            cardElement.classList.remove('discard-selected');
        } else {
            // Не даем выбрать больше карт, чем нужно сбросить
            if (flDiscardSelection.size < requiredDiscard) {
                flDiscardSelection.add(cardStr);
                cardElement.classList.add('discard-selected');
            } else {
                 // Можно добавить сообщение пользователю
                 console.log("JS: Maximum discard selection reached");
            }
        }
        updateUIState(); // Обновляем состояние кнопки "Готов"
    }

    // --- Функции взаимодействия с бэкендом ---
    async function startGame() {
         // console.log("JS: startGame START");
         if (startButton.disabled) { /* console.log("JS: Start button is disabled"); */ return; }
         messageArea.textContent = "Начинаем новый раунд...";
         messageArea.style.color = '#333'; // Сброс цвета ошибки
         startButton.disabled = true;
         readyButton.disabled = true;
         waitingOverlay.style.display = 'flex';
         clearUIState(); // Очищаем предыдущее состояние UI

         try {
              // console.log("JS: Sending POST request to /start");
              const response = await fetch('/start', { method: 'POST' });
              // console.log(`JS: Received response from /start with status ${response.status}`);
              if (!response.ok) {
                  const errorText = await response.text();
                  throw new Error(`Start game failed: ${response.status} ${errorText}`);
              }
              const data = await response.json();
              // console.log("JS: Received state after /start:", JSON.stringify(data));
              updateUI(data); // Обновляем UI с новым состоянием
         } catch (error) {
              console.error('JS Error starting game:', error);
              messageArea.textContent = `Ошибка начала раунда: ${error.message}`;
              messageArea.style.color = 'red';
              startButton.disabled = false; // Разрешаем попробовать снова
              waitingOverlay.style.display = 'none';
         }
         // console.log("JS: startGame FINISHED");
    }

    async function confirmTurn() {
        // console.log("JS: confirmTurn START");
        if (readyButton.disabled || !currentGameState) { /* console.log("JS: confirmTurn called but button disabled or no state"); */ return; }

        let movePayload = {};
        const isFL = currentGameState.isFantasylandRound && currentGameState.playerFantasylandStatus;

        try { // Добавляем try-catch для сборки данных хода
            if (isFL) {
                // --- Сбор данных для Фантазии ---
                const placement = { top: [], middle: [], bottom: [] };
                const placedCards = new Set();
                placedCardsMap.forEach((value, key) => {
                    if (placement[value.row]) {
                        // Заполняем None, если карты размещены не по порядку
                        while (placement[value.row].length < value.index) {
                             placement[value.row].push(null); // Используем null как плейсхолдер
                        }
                        placement[value.row][value.index] = key; // key это cardStr
                        placedCards.add(key);
                    }
                });
                // Заменяем null на "__" и проверяем количество
                for (const row in placement) {
                     const capacity = row === 'top' ? 3 : 5;
                     // Дополняем null до нужной длины
                     while(placement[row].length < capacity) { placement[row].push(null); }
                     // Заменяем null на "__"
                     placement[row] = placement[row].map(c => c === null ? "__" : c);
                     if (placement[row].filter(c => c !== "__").length !== (row === 'top' ? 3 : 5)) {
                          throw new Error("Не все карты размещены для Фантазии.");
                     }
                }

                const discarded = Array.from(flDiscardSelection);
                const originalHandSize = currentGameState.fantasylandHand?.length || 0;
                const requiredDiscard = Math.max(0, originalHandSize - 13);
                if (discarded.length !== requiredDiscard) {
                     throw new Error(`Неверное количество карт для сброса (нужно ${requiredDiscard}, выбрано ${discarded.length}).`);
                }
                movePayload = { placement: placement, discarded: discarded };
                // console.log("JS confirmTurn FL Payload:", JSON.stringify(movePayload));

            } else {
                // --- Сбор данных для обычного хода ---
                if (currentGameState.street === 1) {
                    if (placedCardsMap.size !== 5) throw new Error("Нужно разместить 5 карт на улице 1.");
                    const placements = [];
                    placedCardsMap.forEach((value, key) => {
                        placements.push({ card: key, row: value.row, index: value.index });
                    });
                    // Сортируем для консистентности (не обязательно)
                    placements.sort((a, b) => a.row.localeCompare(b.row) || a.index - b.index);
                    movePayload = { placements: placements };
                } else { // Улицы 2-5
                    if (placedCardsMap.size !== 2) throw new Error("Нужно разместить 2 карты.");
                    if (!selectedCardToDiscardElement) throw new Error("Нужно выбрать карту для сброса.");
                    const placements = [];
                    placedCardsMap.forEach((value, key) => {
                        placements.push({ card: key, row: value.row, index: value.index });
                    });
                    placements.sort((a, b) => a.row.localeCompare(b.row) || a.index - b.index);
                    movePayload = {
                        placements: placements,
                        discard: selectedCardToDiscardElement.dataset.card
                    };
                }
                // console.log(`JS confirmTurn Street ${currentGameState.street} Payload:`, JSON.stringify(movePayload));
            }
        } catch (error) {
             console.error("JS Error preparing move data:", error);
             messageArea.textContent = `Ошибка подготовки хода: ${error.message}`;
             messageArea.style.color = 'red';
             return; // Не отправляем ход
        }

        // Блокируем кнопки и показываем оверлей
        readyButton.disabled = true;
        startButton.disabled = true; // Блокируем и старт на всякий случай
        waitingOverlay.style.display = 'flex';
        messageArea.textContent = "Отправка хода...";
        messageArea.style.color = '#333';

        // Отправляем ход на сервер
        try {
            // console.log("JS: Sending POST request to /move");
            const response = await fetch('/move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(movePayload)
            });
            // console.log(`JS: Received response from /move with status ${response.status}`);

            const data = await response.json();
            // console.log("JS: Received state after /move:", JSON.stringify(data));

            if (!response.ok) {
                // Ошибка от сервера (например, невалидный ход)
                throw new Error(data.error || data.error_message || `Move failed: ${response.status}`);
            }

            // Успешно, обновляем UI
            updateUI(data);

        } catch (error) {
            console.error('JS Error sending move:', error);
            messageArea.textContent = `Ошибка хода: ${error.message}`;
            messageArea.style.color = 'red';
            // Разблокируем кнопку "Готов", чтобы можно было исправить ход
            // Но только если ошибка не связана с завершением раунда
            if (currentGameState && !currentGameState.isGameOver && !currentGameState.playerFinishedRound) {
                 readyButton.disabled = false; // Позволяем исправить
            }
            waitingOverlay.style.display = 'none'; // Скрываем оверлей при ошибке
        } finally {
             // Очищаем состояние UI после отправки (успешной или нет)
             // Это делается внутри updateUI при получении нового состояния
             // clearUIState(); // Не нужно здесь, т.к. updateUI вызывается
        }
        // console.log("JS: confirmTurn FINISHED");
    }

     async function fetchAndUpdateState() {
         // console.log("JS: fetchAndUpdateState START");
         messageArea.textContent = "Загрузка...";
         messageArea.style.color = '#333';
         try {
             // console.log("JS: Sending GET request to /api/game_state");
             const response = await fetch('/api/game_state');
             // console.log(`JS: Received response from /api/game_state with status ${response.status}`);
             if (!response.ok) {
                 const errorText = await response.text();
                 throw new Error(`Fetch state failed: ${response.status} ${errorText}`);
             }
             const data = await response.json();
             // console.log("JS: Received initial/updated state:", JSON.stringify(data));
             if (data.error_message) {
                 console.error("JS Error from API:", data.error_message);
                 messageArea.textContent += ` | Ошибка сервера: ${data.error_message}`;
                 messageArea.style.color = 'red';
             }
             updateUI(data); // Обновляем UI полученными данными
         } catch (error) {
             console.error("JS Error fetching game state:", error);
             messageArea.textContent = "Ошибка сети при загрузке состояния игры.";
             messageArea.style.color = 'red';
             startButton.disabled = false; // Позволяем начать заново
             readyButton.disabled = true;
             waitingOverlay.style.display = 'none';
         }
         // console.log("JS: fetchAndUpdateState FINISHED");
     }

     function toggleFullScreen() {
         // console.log("JS: toggleFullScreen START");
         try {
             const fsIcon = document.querySelector('.fullscreen-btn .material-icons');
             if (!document.fullscreenElement) {
                 if (document.documentElement.requestFullscreen) {
                     document.documentElement.requestFullscreen()
                         .then(() => { /* console.log("JS: Fullscreen entered"); */ if(fsIcon) fsIcon.textContent = 'fullscreen_exit'; })
                         .catch(err => console.error(`JS Error attempting to enable full-screen mode: ${err.message} (${err.name})`));
                 } else { console.warn("JS: Fullscreen API not supported"); }
             } else {
                 if (document.exitFullscreen) {
                     document.exitFullscreen()
                         .then(() => { /* console.log("JS: Fullscreen exited"); */ if(fsIcon) fsIcon.textContent = 'fullscreen'; })
                         .catch(err => console.error(`JS Error attempting to exit full-screen mode: ${err.message} (${err.name})`));
                 }
             }
         } catch (error) { console.error("JS Error toggling fullscreen:", error); }
         // console.log("JS: toggleFullScreen FINISHED");
     }

    // --- Вспомогательный объект для работы с картами ---
    const CardHelper = {
         ranks: '23456789TJQKA',
         suits: 'cdhs',
         rankValues: {'2':0,'3':1,'4':2,'5':3,'6':4,'7':5,'8':6,'9':7,'T':8,'J':9,'Q':10,'K':11,'A':12},
         isValidRank: function(r) { return this.ranks.includes(r.toUpperCase()); },
         isValidSuit: function(s) { return this.suits.includes(s.toLowerCase()); },
         getRankValue: function(cardStr) {
             if (!cardStr || cardStr === "__") return -1;
             const rank = cardStr.length > 2 && cardStr.startsWith('T') ? 'T' : cardStr.substring(0, 1).toUpperCase();
             return this.rankValues[rank] ?? -1;
         },
         compareCards: function(cardA, cardB) {
             const rankValueA = CardHelper.getRankValue(cardA);
             const rankValueB = CardHelper.getRankValue(cardB);
             // Сначала по рангу (по убыванию), потом по масти (для стабильности)
             if (rankValueB !== rankValueA) {
                 return rankValueB - rankValueA;
             } else {
                 const suitA = cardA.substring(cardA.length - 1);
                 const suitB = cardB.substring(cardB.length - 1);
                 return suitA.localeCompare(suitB); // Сортировка по масти (cdhs)
             }
         }
    };


    // --- Инициализация ---
    document.addEventListener('DOMContentLoaded', () => {
        // console.log("JS: DOMContentLoaded event START");
        fetchAndUpdateState(); // Загружаем начальное состояние
        // Назначаем обработчики DnD
        document.addEventListener('dragstart', handleDragStart);
        document.addEventListener('dragover', handleDragOver);
        document.addEventListener('dragleave', handleDragLeave);
        document.addEventListener('drop', handleDrop);
        document.addEventListener('dragend', handleDragEnd);
        // console.log("JS: DOMContentLoaded event FINISHED");
    });

</script>
</body>
</html>
