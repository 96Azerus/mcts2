<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>OFC Pineapple AI</title>
    <!-- Адаптация под мобильные устройства -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <!-- Подключаем SortableJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <style>
        /* Общие стили */
        :root {
            /* Уменьшаем размеры для лучшего отображения на мобильных */
            --card-width: 40px; --card-height: 60px; --card-font-size: 12px;
            --card-rank-font-size: 1.1em; --card-suit-font-size: 0.8em;
            --row-gap: 5px; --row-min-height: 70px; --table-padding: 8px;
            --hand-area-padding: 8px; --hand-gap: 5px;
        }
        html { box-sizing: border-box; -webkit-tap-highlight-color: transparent; /* Убираем синюю подсветку при тапе */ }
        *, *:before, *:after { box-sizing: inherit; }
        body { margin: 0; padding: 10px; font-family: Arial, sans-serif; background-color: #f0f0f0; overflow-x: hidden; min-height: 100vh; padding-bottom: 130px; /* Увеличил отступ снизу */ display: flex; flex-direction: column; }
        button { padding: 10px 15px; font-size: 14px; border: none; border-radius: 5px; cursor: pointer; background-color: #4CAF50; color: white; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.2); -webkit-tap-highlight-color: transparent; }
        button:hover:not(:disabled) { background-color: #45a049; transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        button:active:not(:disabled) { transform: translateY(1px); box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        button:disabled { background-color: #cccccc; cursor: not-allowed; opacity: 0.7; }

        /* Управление */
        .controls { display: flex; justify-content: center; flex-wrap: wrap; gap: 10px; margin-bottom: 15px; position: sticky; top: 0; z-index: 1001; background: #f0f0f0; padding: 10px; border-bottom: 1px solid #ccc; }
        .fullscreen-btn { position: fixed; top: 5px; right: 5px; background: none; border: none; color: #333; cursor: pointer; z-index: 1002; padding: 5px; box-shadow: none; }
        .fullscreen-btn .material-icons { font-size: 28px; }

        /* Игровой стол */
        .game-area { display: flex; flex-direction: column; align-items: center; width: 100%; }
        .table { display: grid; grid-template-rows: auto auto auto; gap: var(--row-gap); margin: 10px auto; width: 98%; max-width: 600px; background-color: #1a472a; padding: var(--table-padding); border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .row { display: flex; justify-content: center; gap: 1.5%; min-height: var(--row-min-height); padding: 5px; border-radius: 5px; background-color: rgba(255,255,255,0.1); flex-wrap: nowrap; align-items: center; }
        .player-label { text-align: center; color: white; font-weight: bold; margin-bottom: 3px; font-size: 13px; }

        /* Карты и слоты */
        .card {
            width: var(--card-width); height: var(--card-height); border-radius: 4px; background-color: white;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            font-size: var(--card-font-size); font-weight: bold; box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            position: relative; flex-shrink: 0;
            transition: transform 0.2s, box-shadow 0.2s, border 0.2s;
            user-select: none; -webkit-user-select: none; /* Отключаем выделение текста */
            touch-action: none; /* Отключаем стандартные действия браузера при касании (важно!) */
            border: 1px solid #bbb; /* Сделал рамку чуть виднее */
            padding: 1px;
            cursor: grab; /* Курсор для перетаскивания */
        }
        .card span:first-child { font-size: var(--card-rank-font-size); }
        .card span:last-child { font-size: var(--card-suit-font-size); margin-top: 1px; }
        .card[data-suit="♥"], .card[data-suit="♦"] { color: #e44145; }
        .card[data-suit="♣"], .card[data-suit="♠"] { color: #2d2d2d; }
        /* Стили для перетаскивания SortableJS */
        .card.sortable-ghost { opacity: 0.4; background: #cce; /* Стиль для "тени" карты */ }
        .card.sortable-chosen { cursor: grabbing; /* Курсор при перетаскивании */ }
        .card.selected { border: 2px solid #dc3545 !important; background-color: rgba(220, 53, 69, 0.1); }
        .card-slot { width: var(--card-width); height: var(--card-height); border: 1px dashed rgba(255,255,255,0.3); border-radius: 4px; flex-shrink: 0; transition: background-color 0.3s ease; display: flex; justify-content: center; align-items: center; }
        .card-slot.available { border: 2px dashed #aaffaa; }
        /* Подсветка слота, куда можно бросить карту */
        .card-slot.sortable-drag-over-target { background-color: rgba(170, 255, 170, 0.4); border-style: solid; }
        .card-slot .card { cursor: default; } /* Карты в слотах не перетаскиваются по умолчанию */
        .card-slot .card.placed-this-turn { cursor: grab; } /* Карты, размещенные в этом ходу, можно вернуть */

        /* Область руки и сброса */
        #hand-area { position: fixed; bottom: 0; left: 0; right: 0; background: #e0e0e0; padding: var(--hand-area-padding); display: flex; flex-direction: column; justify-content: center; gap: 8px; z-index: 1000; box-shadow: 0 -2px 10px rgba(0,0,0,0.1); min-height: 90px; align-items: center;}
        #hand { display: flex; justify-content: center; gap: var(--hand-gap); flex-wrap: wrap; min-height: 70px; width: 100%; }
        #hand .card.placed { display: none; } /* Карты, помеченные как placed, скрываются из руки */
        #fl-discard-area { margin-top: 5px; text-align: center; width: 100%; }
        #fl-discard-area span { font-size: 12px; color: #555; display: block; margin-bottom: 5px; }
        #fl-discard-options { display: flex; justify-content: center; gap: 5px; flex-wrap: wrap; }
        #fl-discard-options .card { border: 1px solid #ccc; cursor: pointer; }
        #fl-discard-options .card.discard-selected { border: 2px solid #dc3545 !important; background-color: rgba(220, 53, 69, 0.1); }
        .player-discard-info { margin-top: 5px; text-align: center; color: #555; font-size: 12px; padding: 0 10px; width: 100%; }

        /* Сообщения и оверлей */
        .message-area { text-align: center; margin-bottom: 10px; font-weight: bold; color: #333; min-height: 20px; font-size: 14px;}
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 1005; display: flex; justify-content: center; align-items: center; color: white; font-size: 1.5em; display: none; /* СКРЫТ ПО УМОЛЧАНИЮ */ }

        /* --- Мобильная адаптация --- */
        @media (max-width: 640px) {
             /* Размеры уже уменьшены в :root */
            body { padding-bottom: 130px; padding-left: 5px; padding-right: 5px; }
            .controls button { padding: 8px 12px; font-size: 14px; }
            .player-label { font-size: 12px; }
            .message-area { font-size: 13px; }
            #hand-area { min-height: 80px; }
            #hand { min-height: 65px; }
            .player-discard-info { font-size: 11px; }
            #fl-discard-area span { font-size: 11px; }
        }
         @media (max-width: 380px) {
             :root { --card-width: 34px; --card-height: 52px; --card-font-size: 10px; --row-min-height: 62px; --hand-gap: 3px;}
             .controls { gap: 5px; }
             .controls button { padding: 6px 10px; font-size: 12px; }
             .player-label { font-size: 11px; }
             .message-area { font-size: 12px; }
         }
    </style>
</head>
<body>
    <button class="fullscreen-btn" onclick="toggleFullScreen()" title="Полный экран">
        <span class="material-icons">fullscreen</span>
    </button>

    <div class="controls">
        <button id="start-button" onclick="startGame()">Начать Раунд</button>
        <button id="ready-button" onclick="confirmTurn()" disabled>Готов</button>
    </div>

    <div class="message-area" id="message-area">Загрузка...</div>

    <div class="game-area">
         <div class="player-label">AI Player</div>
        <div class="table" id="ai-table">
            <!-- Добавляем data-row атрибуты для идентификации в SortableJS -->
            <div class="row top" id="ai-top-row" data-row="top"></div>
            <div class="row middle" id="ai-middle-row" data-row="middle"></div>
            <div class="row bottom" id="ai-bottom-row" data-row="bottom"></div>
        </div>

        <div class="player-label">Human Player (Вы)</div>
        <div class="table" id="player-table">
            <!-- Добавляем data-row атрибуты для идентификации в SortableJS -->
            <div class="row top" id="player-top-row" data-row="top"></div>
            <div class="row middle" id="player-middle-row" data-row="middle"></div>
            <div class="row bottom" id="player-bottom-row" data-row="bottom"></div>
        </div>
    </div>

    <div id="hand-area">
        <!-- Добавляем data-row атрибут для идентификации в SortableJS -->
        <div id="hand" data-row="hand"></div>
        <div id="fl-discard-area" style="display: none;">
             <span>Выберите карту(ы) для сброса:</span>
             <div id="fl-discard-options"></div>
        </div>
        <div class="player-discard-info" id="player-discard-info">Ваш сброс: 0 карт</div>
    </div>

    <div class="overlay" id="waiting-overlay">Ожидание...</div>

<script>
    // --- Глобальные переменные ---
    let currentGameState = null;
    let humanPlayerIndex = 0;
    // let draggedCardElement = null; // Больше не нужно для SortableJS
    let placedCardsMap = new Map(); // cardStr -> { element, row, index, isFinal } - ОСТАВЛЯЕМ для отслеживания состояния
    let selectedCardToDiscardElement = null; // Для улиц 2-5
    let flDiscardSelection = new Set(); // cardStr - для ФЛ
    let sortableInstances = {}; // Хранилище для экземпляров SortableJS

    // --- Ссылки на DOM элементы ---
    const readyButton = document.getElementById('ready-button');
    const messageArea = document.getElementById('message-area');
    const handElement = document.getElementById('hand');
    const playerDiscardInfo = document.getElementById('player-discard-info');
    const waitingOverlay = document.getElementById('waiting-overlay');
    const flDiscardArea = document.getElementById('fl-discard-area');
    const flDiscardOptions = document.getElementById('fl-discard-options');
    const startButton = document.getElementById('start-button');
    const playerRows = {
        top: document.getElementById('player-top-row'),
        middle: document.getElementById('player-middle-row'),
        bottom: document.getElementById('player-bottom-row')
    };

    // --- ИЗМЕНЕНИЕ: Удалены старые обработчики DnD ---
    // function handleDragStart(event) { ... }
    // function handleDragOver(event) { ... }
    // function handleDragLeave(event) { ... }
    // function handleDrop(event) { ... }
    // function handleDragEnd(event) { ... }

    // --- Вспомогательные функции (без изменений) ---
    function getCardSuitSymbol(suitChar) { const map = {'c': '♣', 'd': '♦', 'h': '♥', 's': '♠'}; return map[suitChar.toLowerCase()] || suitChar; }
    function createCardElement(cardStr, isDraggable = false) {
        // console.log(`JS: createCardElement for ${cardStr}`);
        if (!cardStr || cardStr === "__" || cardStr === "InvalidCard") { return null; }
        try {
            const cardElement = document.createElement('div');
            cardElement.className = 'card';
            const rank = cardStr.length > 2 && cardStr.startsWith('T') ? 'T' : cardStr.substring(0, 1);
            const suitChar = cardStr.substring(cardStr.length - 1);
            const suitSymbol = getCardSuitSymbol(suitChar);

            if (!rank || !suitSymbol || !CardHelper.isValidRank(rank) || !CardHelper.isValidSuit(suitChar)) {
                 console.error(`JS Error: Could not parse rank/suit from ${cardStr}`); return null;
            }

            cardElement.dataset.card = cardStr;
            cardElement.dataset.rank = rank;
            cardElement.dataset.suit = suitSymbol;
            cardElement.innerHTML = `<span>${rank.toUpperCase()}</span><span>${suitSymbol}</span>`;

            if (suitSymbol === '♥' || suitSymbol === '♦') { cardElement.style.color = '#e44145'; }
            else { cardElement.style.color = '#2d2d2d'; }

            // isDraggable больше не используется напрямую для атрибута draggable
            // SortableJS сам определяет перетаскиваемые элементы по селектору
            cardElement.style.cursor = 'grab'; // Устанавливаем курсор

            return cardElement;
        } catch (error) {
             console.error(`JS Error in createCardElement for ${cardStr}:`, error); return null;
        }
    }
    function createCardSlotElement(row, index, isPlayerBoard = false) {
        const slot = document.createElement('div');
        slot.className = 'card-slot';
        slot.dataset.row = row;
        slot.dataset.index = index;
        // Класс available добавляется/удаляется в updateUIState
        return slot;
    }

    // --- ИЗМЕНЕНИЕ: Инициализация SortableJS ---
    function initializeSortables() {
        const sortableOptions = {
            group: 'cards', // Позволяет перетаскивать между этими контейнерами
            animation: 150, // Анимация перемещения
            draggable: '.card', // Указываем, что перетаскивать можно только карты
            ghostClass: 'sortable-ghost', // Класс для "тени" перетаскиваемой карты
            chosenClass: 'sortable-chosen', // Класс для выбранной карты
            filter: '.selected', // Нельзя перетаскивать карты, выбранные для сброса
            preventOnFilter: false, // Разрешить стандартные действия для отфильтрованных элементов (если нужно)
            onEnd: handleSortableEnd, // Обработчик завершения перетаскивания
            // Добавляем класс для подсветки цели при перетаскивании
            onMove: function (evt) {
                 // Подсвечиваем слот, над которым происходит перетаскивание
                 document.querySelectorAll('.sortable-drag-over-target').forEach(el => el.classList.remove('sortable-drag-over-target'));
                 if (evt.to.classList.contains('card-slot') && evt.to.classList.contains('available')) {
                      evt.to.classList.add('sortable-drag-over-target');
                 } else if (evt.to.id === 'hand' && evt.item.classList.contains('placed-this-turn')) {
                      // Можно добавить подсветку руки при возврате
                 }
            },
            // Убираем подсветку после завершения
            onUnchoose: function(evt) {
                 document.querySelectorAll('.sortable-drag-over-target').forEach(el => el.classList.remove('sortable-drag-over-target'));
            }
        };

        // Уничтожаем старые экземпляры, если они есть
        Object.values(sortableInstances).forEach(instance => instance.destroy());
        sortableInstances = {};

        // Инициализируем для руки
        if (handElement) {
            sortableInstances.hand = new Sortable(handElement, sortableOptions);
        }
        // Инициализируем для рядов игрока
        Object.entries(playerRows).forEach(([rowName, rowElement]) => {
            if (rowElement) {
                sortableInstances[rowName] = new Sortable(rowElement, {
                    ...sortableOptions,
                    // Дополнительно: можно запретить сортировку внутри ряда, если нужно
                    // sort: false,
                });
            }
        });
        // console.log("JS: Sortables initialized", sortableInstances);
    }

    // --- ИЗМЕНЕНИЕ: Обработчик события SortableJS ---
    function handleSortableEnd(event) {
        // console.log("JS: handleSortableEnd", event);
        const itemEl = event.item; // Перемещенный элемент (карта)
        const toList = event.to;   // Контейнер, куда переместили
        const fromList = event.from; // Контейнер, откуда переместили
        const cardStr = itemEl.dataset.card;
        const oldIndex = event.oldIndex; // Индекс в старом контейнере
        const newIndex = event.newIndex; // Индекс в новом контейнере

        // Убираем подсветку цели
        document.querySelectorAll('.sortable-drag-over-target').forEach(el => el.classList.remove('sortable-drag-over-target'));

        if (!cardStr) return;

        const targetIsHand = toList.id === 'hand';
        const sourceIsHand = fromList.id === 'hand';
        const targetIsBoard = toList.classList.contains('row');
        const sourceIsBoard = fromList.classList.contains('row');

        // --- Логика обновления placedCardsMap ---

        // 1. Карта перемещена из руки на доску ИЛИ с доски на доску
        if (targetIsBoard) {
            const targetRowElement = toList;
            const targetRowName = targetRowElement.dataset.row;
            // Находим слот, в который попала карта
            const targetSlot = targetRowElement.children[newIndex];

            if (targetSlot && targetSlot.classList.contains('card-slot')) {
                 // Проверяем, пуст ли слот (SortableJS может поместить карту рядом, а не внутрь)
                 if (targetSlot.children.length > 1) { // Если в слоте уже есть карта + перетаскиваемая
                      console.warn("JS: Card dropped onto an occupied slot, reverting.");
                      // Отменяем перемещение (возвращаем карту обратно)
                      if (sourceIsHand) {
                           handElement.insertBefore(itemEl, handElement.children[oldIndex]);
                      } else {
                           fromList.insertBefore(itemEl, fromList.children[oldIndex]);
                      }
                      // Обновляем UI, чтобы убрать лишнюю карту из слота
                      renderBoard('player', currentGameState.playerBoard, true); // Перерисовываем доску
                      return;
                 }

                const targetSlotIndex = parseInt(targetSlot.dataset.index);
                // Обновляем карту размещений
                placedCardsMap.set(cardStr, { element: itemEl, row: targetRowName, index: targetSlotIndex, isFinal: false });
                itemEl.classList.add('placed-this-turn'); // Помечаем как размещенную в этом ходу
                itemEl.classList.add('placed'); // Скрываем из вида в руке (если она была оттуда)
                targetSlot.classList.remove('available'); // Слот занят
                // console.log(`JS: Card ${cardStr} placed in ${targetRowName}[${targetSlotIndex}]`);

                // Если карта была перемещена с доски, освобождаем старый слот
                if (sourceIsBoard && fromList !== toList) {
                     const sourceSlot = fromList.children[oldIndex];
                     if (sourceSlot && sourceSlot.classList.contains('card-slot')) {
                          sourceSlot.classList.add('available');
                     }
                }
            } else {
                 console.error("JS: Target slot not found or invalid after drop.");
                 // Попытка вернуть карту обратно (может быть сложно)
                 if (sourceIsHand) handElement.appendChild(itemEl);
                 else fromList.insertBefore(itemEl, fromList.children[oldIndex]);
            }
        }
        // 2. Карта возвращена из доски в руку
        else if (targetIsHand && sourceIsBoard) {
            if (placedCardsMap.has(cardStr)) {
                const oldPlacement = placedCardsMap.get(cardStr);
                const sourceSlot = fromList.children[oldIndex]; // Слот, откуда взяли
                 if (sourceSlot && sourceSlot.classList.contains('card-slot')) {
                     sourceSlot.classList.add('available'); // Освобождаем слот
                 }
                placedCardsMap.delete(cardStr); // Удаляем из размещенных
                itemEl.classList.remove('placed-this-turn');
                itemEl.classList.remove('placed'); // Показываем в руке
                // console.log(`JS: Card ${cardStr} returned to hand from ${oldPlacement.row}[${oldPlacement.index}]`);
            }
        }
        // 3. Карта перемещена внутри руки (ничего не делаем с placedCardsMap)
        else if (targetIsHand && sourceIsHand) {
             // console.log(`JS: Card ${cardStr} moved within hand`);
        }

        // Обновляем состояние UI после любого перемещения
        updateUIState();
    }


    // --- Функции обновления UI (renderBoard без изменений) ---
    function renderBoard(playerPrefix, boardData, isPlayerBoard = false) {
        // console.log(`JS: renderBoard START for ${playerPrefix}`);
        try {
            const rows = {
                top: document.getElementById(`${playerPrefix}-top-row`),
                middle: document.getElementById(`${playerPrefix}-middle-row`),
                bottom: document.getElementById(`${playerPrefix}-bottom-row`)
            };
            if (!rows.top || !rows.middle || !rows.bottom) { console.error("JS Error: Board row elements not found for prefix:", playerPrefix); return; }
            Object.entries(rows).forEach(([rowName, rowElement]) => {
                if(rowElement) {
                    rowElement.innerHTML = ''; // Очищаем ряд
                    const rowCards = boardData[rowName] || [];
                    const capacity = rowName === 'top' ? 3 : 5;
                    for (let i = 0; i < capacity; i++) {
                        const cardStr = rowCards[i] || "__";
                        // Создаем слот всегда
                        const slot = createCardSlotElement(rowName, i, isPlayerBoard);
                        // Пытаемся найти карту, которая УЖЕ МОГЛА БЫТЬ размещена в этом слоте пользователем
                        let existingPlacedCard = null;
                        if (isPlayerBoard && placedCardsMap.size > 0) {
                             for (const [cStr, placement] of placedCardsMap.entries()) {
                                 if (placement.row === rowName && placement.index === i) {
                                     existingPlacedCard = placement.element;
                                     break;
                                 }
                             }
                        }

                        if (existingPlacedCard) {
                             // Если карта уже размещена пользователем, используем ее
                             slot.appendChild(existingPlacedCard);
                             slot.classList.remove('available');
                        } else {
                             // Иначе создаем карту из данных состояния игры
                             const cardEl = createCardElement(cardStr, false);
                             if (cardEl) {
                                 slot.appendChild(cardEl);
                                 if(isPlayerBoard) slot.classList.remove('available');
                             } else if (isPlayerBoard) {
                                 slot.classList.add('available');
                             }
                        }
                        rowElement.appendChild(slot);
                    }
                }
            });
            // console.log(`JS: renderBoard for ${playerPrefix} FINISHED`);
        } catch (error) { console.error(`JS Error in renderBoard for ${playerPrefix}:`, error); }
    }

    function renderHand(handCards) {
        // console.log("JS: renderHand START with cards:", handCards);
        try {
            handElement.innerHTML = '';
            const sortedHand = Array.isArray(handCards) ? [...handCards].sort(CardHelper.compareCards) : [];
            handElement.dataset.currentHand = JSON.stringify(sortedHand);

            if (sortedHand.length > 0) {
                sortedHand.forEach(cardStr => {
                    // Создаем карты, но isDraggable теперь не так важно, SortableJS рулит
                    const cardEl = createCardElement(cardStr, true);
                    if (cardEl) {
                        // Скрываем карту, если она уже размещена на доске
                        if (placedCardsMap.has(cardStr)) {
                            cardEl.classList.add('placed');
                        }
                        handElement.appendChild(cardEl);
                    }
                });
            }
            // Инициализируем или переинициализируем SortableJS ПОСЛЕ рендеринга руки
            initializeSortables();
            // Сбрасываем состояние UI, связанное с предыдущим ходом
            clearUIState(); // Вызываем здесь, чтобы применить состояние к новым элементам
            // console.log("JS: renderHand FINISHED");
        } catch (error) { console.error("JS Error in renderHand:", error); }
    }

    function clearUIState() {
         // console.log("JS: clearUIState START");
         // Сбрасываем только состояние выбора/перетаскивания, НЕ placedCardsMap
         // draggedCardElement = null; // Не используется
         if(selectedCardToDiscardElement) {
             selectedCardToDiscardElement.classList.remove('selected');
             selectedCardToDiscardElement = null;
         }
         flDiscardSelection.clear();
         flDiscardArea.style.display = 'none';
         flDiscardOptions.innerHTML = '';
         // Убираем классы с карт и слотов
         document.querySelectorAll('.card.selected').forEach(c => c.classList.remove('selected'));
         document.querySelectorAll('.card-slot.drag-over').forEach(s => s.classList.remove('drag-over'));
         document.querySelectorAll('.card-slot.sortable-drag-over-target').forEach(s => s.classList.remove('sortable-drag-over-target'));
         // Обновляем состояние кнопок и доступности слотов/перетаскивания
         updateUIState();
         // console.log("JS: clearUIState FINISHED");
    }

    function updateUI(stateData) {
        // console.log("JS: updateUI START with state:", JSON.stringify(stateData));
        if (!stateData || typeof stateData !== 'object') { console.error("JS Error: Invalid stateData received in updateUI", stateData); messageArea.textContent = "Ошибка: Некорректные данные от сервера."; return; }
        try {
            const wasGameOver = currentGameState?.isGameOver ?? true;
            const previousStreet = currentGameState?.street ?? 0;
            const previousHandStr = handElement.dataset.currentHand || '[]';

            currentGameState = stateData;
            humanPlayerIndex = stateData.humanPlayerIndex;

            waitingOverlay.style.display = stateData.isWaiting ? 'flex' : 'none';

            // Рендерим доски (renderBoard теперь учитывает placedCardsMap)
            renderBoard('player', stateData.playerBoard, true);
            renderBoard('ai', stateData.opponentBoard, false);

            const canPlayerAct = !stateData.isGameOver && !stateData.playerFinishedRound && !stateData.isWaiting;
            const isFLTurn = canPlayerAct && stateData.isFantasylandRound && stateData.playerFantasylandStatus;
            const handToRender = isFLTurn ? stateData.fantasylandHand : stateData.hand;
            const currentHandSorted = Array.isArray(handToRender) ? [...handToRender].sort(CardHelper.compareCards) : [];
            const currentHandStr = JSON.stringify(currentHandSorted);

            // Перерисовываем руку, если нужно
            if (canPlayerAct && (currentHandStr !== previousHandStr || (wasGameOver && !stateData.isGameOver) || stateData.street !== previousStreet)) {
                 renderHand(handToRender || []);
            } else if (!canPlayerAct && handElement.children.length > 0) {
                 renderHand([]);
            } else {
                 // Если рука не менялась, просто обновляем состояние UI (включая Sortable)
                 updateUIState();
            }

            playerDiscardInfo.textContent = `Ваш сброс: ${stateData.playerDiscardCount || 0} карт`;
            messageArea.textContent = stateData.message || "Загрузка...";
            if (stateData.error_message) {
                messageArea.textContent += ` | Ошибка: ${stateData.error_message}`;
                messageArea.style.color = 'red';
            } else {
                 messageArea.style.color = '#333';
            }

            startButton.disabled = !stateData.isGameOver;

            // console.log("JS: updateUI FINISHED");
        } catch (error) { console.error("JS Error in updateUI:", error); messageArea.textContent = "Ошибка отображения интерфейса."; }
    }

    function updateUIState() {
        // console.log("JS: updateUIState START");
        if (!currentGameState) { return; }
        try {
            const canPlayerAct = !currentGameState.isGameOver && !currentGameState.playerFinishedRound && !currentGameState.isWaiting;
            const isFL = canPlayerAct && currentGameState.isFantasylandRound && currentGameState.playerFantasylandStatus;
            const placedCount = placedCardsMap.size;
            let requiredPlacement = 0;
            let requiredDiscard = 0;
            let isReady = false;
            flDiscardArea.style.display = 'none';

            if (isFL) {
                requiredPlacement = 13;
                const originalHandSize = currentGameState.fantasylandHand?.length || 0;
                requiredDiscard = Math.max(0, originalHandSize - 13);
                isReady = placedCount === requiredPlacement && flDiscardSelection.size === requiredDiscard;
                readyButton.textContent = "Разместить Фантазию";
                if (canPlayerAct && requiredDiscard > 0) {
                     flDiscardArea.style.display = 'block';
                     flDiscardOptions.innerHTML = '';
                     const handCards = currentGameState.fantasylandHand || [];
                     handCards.forEach(cardStr => {
                         if (!placedCardsMap.has(cardStr)) {
                             const cardEl = createCardElement(cardStr, false);
                             if (cardEl) {
                                 cardEl.style.cursor = 'pointer';
                                 cardEl.onclick = () => toggleFLDiscardSelection(cardEl);
                                 if (flDiscardSelection.has(cardStr)) cardEl.classList.add('discard-selected');
                                 flDiscardOptions.appendChild(cardEl);
                             }
                         }
                     });
                     if(flDiscardOptions.children.length === 0) flDiscardArea.style.display = 'none';
                }
            } else if (canPlayerAct) {
                if (currentGameState.street === 1) { requiredPlacement = 5; requiredDiscard = 0; isReady = placedCount === requiredPlacement; }
                else if (currentGameState.street >= 2 && currentGameState.street <= 5) { requiredPlacement = 2; requiredDiscard = 1; isReady = placedCount === requiredPlacement && !!selectedCardToDiscardElement; }
                readyButton.textContent = "Готов";
            }

            readyButton.disabled = !isReady || !canPlayerAct;

            // Обновляем состояние слотов (доступность для дропа)
            document.querySelectorAll('#player-table .card-slot').forEach(slot => {
                const isOccupied = !!slot.firstChild;
                const canDrop = !isOccupied && canPlayerAct && placedCount < requiredPlacement;
                slot.classList.toggle('available', canDrop);
            });

            // Включаем/выключаем SortableJS
            const enableSortables = canPlayerAct;
            Object.values(sortableInstances).forEach(instance => {
                if (instance) instance.option("disabled", !enableSortables);
            });

            // Обновляем кликабельность карт в руке для сброса
             Array.from(handElement.children).forEach(cardEl => {
                 const cardStr = cardEl.dataset.card;
                 const isPlaced = placedCardsMap.has(cardStr);
                 const isSelectedForDiscard = selectedCardToDiscardElement === cardEl;
                 cardEl.classList.toggle('selected', isSelectedForDiscard);

                 if (!isFL && currentGameState.street > 1 && canPlayerAct && !isPlaced && placedCount === 2) {
                     cardEl.onclick = () => handleCardClick(cardEl);
                     cardEl.style.cursor = 'pointer';
                 } else {
                     cardEl.onclick = null;
                     cardEl.style.cursor = enableSortables ? 'grab' : 'default';
                 }
             });
             // console.log("JS: updateUIState FINISHED");
        } catch(error) { console.error("JS Error in updateUIState:", error); }
    }

    // --- Обработчики действий пользователя (handleCardClick, toggleFLDiscardSelection без изменений) ---
    function handleCardClick(cardElement) { /* ... как раньше ... */ }
    function toggleFLDiscardSelection(cardElement) { /* ... как раньше ... */ }

    // --- Функции взаимодействия с бэкендом (startGame, confirmTurn, fetchAndUpdateState без изменений) ---
    async function startGame() { /* ... как раньше ... */ }
    async function confirmTurn() { /* ... как раньше, но данные собираются из placedCardsMap */ }
    async function fetchAndUpdateState() { /* ... как раньше ... */ }
    function toggleFullScreen() { /* ... как раньше ... */ }

    // --- Вспомогательный объект для работы с картами (без изменений) ---
    const CardHelper = { /* ... как раньше ... */ };

    // --- Инициализация ---
    document.addEventListener('DOMContentLoaded', () => {
        // console.log("JS: DOMContentLoaded event START");
        fetchAndUpdateState(); // Загружаем начальное состояние
        // Инициализация SortableJS будет происходить внутри renderHand/updateUI
        // Старые обработчики DnD удалены
        // console.log("JS: DOMContentLoaded event FINISHED");
    });

</script>
</body>
</html>
